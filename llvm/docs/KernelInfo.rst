==========
KernelInfo
==========

.. contents::
   :local:

Introduction
============

This LLVM IR pass reports various statistics for codes compiled for GPUs.  The
goal of these statistics is to help identify bad code patterns and ways to
mitigate them.  The pass operates at the LLVM IR level so that it can, in
theory, support any LLVM-based compiler for programming languages supporting
GPUs.

By default, the pass is disabled.  For convenience, the command-line option
``-kernel-info-end-lto`` inserts it at the end of LTO, and options like
``-Rpass=kernel-info`` enable its remarks.  Example ``opt`` and ``clang``
command lines appear in the next section.

Remarks include summary statistics (e.g., total size of static allocas) and
individual occurrences (e.g., source location of each alloca).  Examples of the
output appear in tests in `llvm/test/Analysis/KernelInfo`.

Example Command Lines
=====================

To analyze a C program as it appears to an LLVM GPU backend at the end of LTO:

.. code-block:: shell

  $ clang -O2 -g -fopenmp --offload-arch=native test.c -foffload-lto \
      -Rpass=kernel-info -mllvm -kernel-info-end-lto

To analyze specified LLVM IR, perhaps previously generated by something like
``clang -save-temps -g -fopenmp --offload-arch=native test.c``:

.. code-block:: shell

  $ opt -disable-output test-openmp-nvptx64-nvidia-cuda-sm_70.bc \
      -pass-remarks=kernel-info -passes=kernel-info

kernel-info can also be inserted into a specified LLVM pass pipeline using
``-kernel-info-end-lto``, or it can be positioned explicitly in that pipeline:

.. code-block:: shell

  $ clang -O2 -g -fopenmp --offload-arch=native test.c -foffload-lto \
      -Rpass=kernel-info -mllvm -kernel-info-end-lto \
      -Xoffload-linker --lto-newpm-passes='lto<O2>'

  $ clang -O2 -g -fopenmp --offload-arch=native test.c -foffload-lto \
      -Rpass=kernel-info \
      -Xoffload-linker --lto-newpm-passes='lto<O2>,module(kernel-info)'

  $ opt -disable-output test-openmp-nvptx64-nvidia-cuda-sm_70.bc \
      -pass-remarks=kernel-info -kernel-info-end-lto -passes='lto<O2>'

  $ opt -disable-output test-openmp-nvptx64-nvidia-cuda-sm_70.bc \
      -pass-remarks=kernel-info -passes='lto<O2>,module(kernel-info)'

PGO
===

Using LLVM's PGO implementation for GPUs, profile data can augment the info
reported by kernel-info.  In particular, an estimate of the number of floating
point operations executed can be reported.

For example, the following computes 2\ :sup:`4`\ , so we expect 4 fmul
instructions to be executed at run time:

.. code-block:: shell

  $ cat test.c
  #include <stdio.h>
  #include <stdlib.h>
  __attribute__((noinline))
  double test(double x, int n) {
    double res = 1;
    for (int i = 0; i < n; ++i)
      res *= x;
    return res;
  }
  int main(int argc, char *argv[]) {
    double x = atof(argv[1]);
    unsigned n = atoi(argv[2]);
    #pragma omp target map(tofrom:x)
    x = test(x, n);
    printf("%f\n", x);
    return 0;
  }

  $ clang -O1 -g -fopenmp --offload-arch=native test.c -o test \
        -fprofile-generate -fprofile-generate-gpu

  $ LLVM_PROFILE_FILE=test.profraw ./test 2 4
  16.000000

  $ llvm-profdata merge -output=test.profdata *.profraw

  $ clang -O1 -g -fopenmp --offload-arch=native test.c -foffload-lto \
        -Rpass=kernel-info -mllvm -kernel-info-end-lto \
        -fprofile-use-gpu=test.profdata | \
      grep "test.c:.*Floating\|double"
  test.c:13:0: in artificial function '__omp_offloading_35_1369040_main_l13', FloatingPointOpProfileCount = 0
  test.c:7:9: in function 'test.internalized', double 'fmul' ('%9') executed 4 times
  test.c:4:0: in function 'test.internalized', FloatingPointOpProfileCount = 4
